var a = 2

编译器：负责语法分析和代码生成
js引擎：负责 整个编译 执行的驱动
作用域：负责 收集维护所有声明的变量组成的查询，确定执行中的代码对变量的访问权限


js与其他的编译语言的其中一个区别是，js引擎不会化大量的时间去进行优化，而js的编译过程不是发生在构建之前的
而是发生在 代码片段 即将执行之前极短时间

编译过程：1.词法分析：将代码字符串分解成有意义的词法单元，例如：var，a ，= ，2

           2.语法分析：将词法单元转化成一个逐级嵌套的树形结构，也就是抽象语法树AST 。会有一个变量声明的顶级节点，
            其下有个 标识符子节点 代表变量名a，以及一个赋值表达子节点，这个子节点有个数值变量子节点，其值为2

            3.代码生成：将抽象语法树转化为可执行代码，语义为 来创建一个变量a 并将一个值2储存在a中

在代码生成、并执行的实际过程：
1.遇到 var a，编译器会问当前作用域是否有一个叫a的变量名，如果有，则忽略该声明语句，继续编译。如果没有就会在当前作用域声明一
个叫a新变量

2.编译器生成引擎可运行的代码，用来处理 a=2这个操作。引擎运行时会询问当前作用域，是否存在一个a的变量，如果存在，就使用这个变量；
如果不存在，就继续查找这个变量（作用域链），如果引擎最终找到a变量就会把2赋值给它，如果没有找到就报错。

综上：变量的赋值会执行两个动作，1.编译器在作用域中查找或声明 2.引擎会在作用域中查找 并赋值。也就是说编译器负责声明，引擎负责赋值


引擎查找的过程：a = 2 ,赋值操作左边的内容进行LHS查找，即查询到变量的容器；赋值操作右边的内容进行RHS查找，即查询赋值的值

栗子：console.log(a) 这里的a是一个RHS查找，因为这个操作是为了找到a所代表的值，并将其扔给console.log()
而 a=2 的a则是LHS查找

总结来说：LHS关注于赋值操作的目标是谁，RHS关注于赋值操作的源头是谁

function foo(a) {
    console.log( a );
}

foo( 2 );


function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );


function foo(a) {
    console.log( a + b );
}
var b = 2;
foo( 2 );

作用域嵌套情况中的查找：RHS在本级作用域找不到会向上级作用域查找，直到找到该变量，或者达到全局作用域为止，如果找不到，则
报引用错误ReferenceError，作用域判别失败

LHS在本级作用域中找不到也会向上查找，直到找到该变量，或者到全局作用域为止，不同的，是如果查询失败，在非严格模式下，会隐式在全局
作用域下创建一个查找所需的变量，在严格模式下报ReferenceError错误

总结：作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对
变量进行赋值，那么就会使用LHS 查询；如果目的是获取变量的值，就会使用RHS 查询。

